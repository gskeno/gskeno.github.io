---
layout: post
title: 分治算法
tags:
- data-structure
categories: data-structure
description: 分治算法
---

本章我们介绍一下分治算法的概念及其使用场景，然后给出一些经典的例子，以加深对分治算法的理解。

<!-- more -->


## 1. 基本概念

在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题...，直到最后子问题可以简单的直接求解，原问题的解即是子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序），傅立叶变换（快速傅立叶变换）...

分治算法主要有3点：

* 分： 将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题

* 治： 最后的子问题可以简单的直接求解

* 合： 将所有子问题的解合并起来就是原问题的解

这3点是分治算法的主要特点，只要是符合这三个特点的问题都可以使用分治算法进行解决。

## 2. 分治算法的特征
分治算法所能解决的问题一般具有以下几个特征：

* 该问题的规模缩小到一定程度就可以容易地解决；

* 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；

* 利用该问题分解出的子问题的解可以合并为该问题的解；

* 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题


第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

第二条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用；

第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心算法或者动态规划算法；

第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

## 3. 如何正确使用分治法？

为什么用分治算法？我们使用一种算法的原因大部分情况下都是为了```“快”```，只有在少数情况下，在程序已经足够```快```的前提下，我们才会牺牲一部分的```快```，去保全一些开发因素（比如，程序的可维护性等等），那么分治算法为什么快？我们在用这个算法之前必须理解清楚这个问题。

分治算法的思想就是将一个规模比较大的问题划分为几个相同逻辑性质（或者直接理解为类似）的规模较小的子问题，我们可以从这里入手。

举一个超级简单的例子：假如有一个存在n个元素的int型数组，我们需要求该数组的和。

可能有些人想都不想就是一个分治算法，将这个问题分为两个子问题，然后每个问题再分为两个子问题，当子问题的规模为只有两个数时进行相加。

然而，这种办法是使用了分治算法，可是效率比直接遍历一遍相加得到的效率还要低得多。

为什么？因为分治算法本身不适合这种单次遍历就可以搞定的简单问题，我们再来回顾一下分治算法的思想：分治算法的思想就是将一个规模较大的问题划分为几个相同逻辑性质的规模较小的子问题，那么这个定义存在一个隐含的前提，当问题规模比较大时，该问题解决起来要成倍的困难！

我们可以举这样一个简单的例子：

对一个存在n个元素的数组，使用简单排序方法来进行排序时：
<pre>
当n=1时，无需比较；

当n=2时，我们需要比较1次；

当n=3时，我们需要比较3次；

当n=4时，我们需要6次比较；
</pre>
从上面可以看到，当n的数值比较大时，我们需要的比较次数越来越多将会是一个巨大的数字。

而对于前面求和的例子：
<pre>
当n=1时，无需相加；

当n=2时，我们需要1次相加；

当n=3时，我们需要两次相加；

当n=4时，我们需要3次相加；
</pre>
仔细观察这组数据，是否发现了什么？

对于求和的例子来说，该问题的计算量与问题规模成正比，在相同条件下，我们根本无需使用分治算法，因为即使这个问题规模变大，他的解决问题的难易程度没有丝毫改变，它所付出的只不过是增大了问题规模后所必须付出的计算量，概括起来就是线性增长的问题规模导致了线性增长的计算量。

而对于排序的例子，当问题规模变大时，计算量的增大是呈幂次型增长的，概括起来就是线性增长的问题规模导致了幂次型计算量的增长，从而使得规模大的问题解决起来更加困难。

综合来说，在问题规模与计算量成正比的算法中，分治算法不是最好的解法，并且可能是效率极其低下的算法。如果存在某个问题，线性增长的问题规模可能带来计算量的非线性增长，并且符合分治算法的三个特征，那么分治算法是一个很不错的选择。

## 4. 分治算法的基本步骤

分治算法在每一层递归上都有三个步骤：

step 1: 分解 -- 将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step 2: 解决 -- 若子问题规模较小且容易被解决则直接解决，否则递归地解决各个子问题；

step 3:: 合并 -- 将各个子问题的解合并为原问题的解；

它的一般算法设计模式如下：
{% highlight string %}
Divide-and-Conquer(P)

	if |P|≤n0
	then return(ADHOC(P))

	将P分解为较小的子问题 P1 ,P2 ,…,Pk

	for i←1 to k
		do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

	T ← MERGE(y1,y2,…,yk) △ 合并子问题

	return(T)
{% endhighlight %}

其中```|P|```表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。

## 5. 可使用分治法求解的一些经典问题

* 二分搜索

* 大整数乘法

* Strassen矩阵乘法

* 棋盘覆盖

* 归并排序

* 快速排序

* 线性时间选择

* 最接近点对问题

* 循环赛日程表

* 汉诺塔

## 6. 依据分治法设计程序时的思维过程

实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序：

1） 一定是先找到最小问题规模时的求解方法；

2） 然后考虑随着问题规模增大时的求解方法；

3） 找到求解的递归函数式后（各种规模或因子），设计递归程序即可



<br />
<br />
**[参看]:**

1. [分治算法（概念、特性、步骤、复杂度分析、经典例子）](https://blog.csdn.net/tianjing0805/article/details/75738698)

2. [五大常用算法——分治算法详解及经典例题](https://blog.csdn.net/qq_37763204/article/details/79519823)

<br />
<br />
<br />


