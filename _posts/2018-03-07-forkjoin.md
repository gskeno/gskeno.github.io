---
layout: post
title: ForkJoin怎么用
tags:
- concurrent-programming
categories: concurrent-programming
description: 如何正确使用使用ForkJoin
---

本文主要介绍java中`ForkJoin`的使用方式，避免踩坑。

<!-- more -->

## 概述
`ForkJoin`使用了`分而治之`的思想，将一个大任务拆分为多个小任务给线程池去执行，可以选择是否将多个字任务的执行结果汇总为一个
最终大结果。如果实际场景下，自定义任务有返回结果，任务可以继承`RecursiveTask`;无需返回结果，可以继承`RecursiveAction`。
在执行过程中，可以利用`工作窃取原理`原理，尽量使得每个线程一直处在工作状态中，避免某些线程一直处在`饥饿`状态，而另外一些线程
却一直处在`繁忙`状态。

**特点**
- 适合使用在`CPU`密集型场景，而非`IO`密集型场景，因为IO密集场景下，不能充分利用多核CPU的优势。
- 与`线程池`相比较，线程池无法很好处理将`子任务执行结果汇总`这样的需求。

## 错误示范
```java
public class CountTask extends RecursiveTask<Long> {
    long begin;
    long end;

    public CountTask(long begin, long end) {
        this.begin = begin;
        this.end = end;
    }

    // 求[begin, end]的所有元素和
    @Override
    protected Long compute() {
        //当begin与end相邻时，任务已经足够小，直接返回
        if (end - begin <= 1) {
            try {
                Thread.sleep(2000);
            } catch (Exception e) {
            }
            return end == begin ? end : begin + end;
        }
        // 继续拆分任务
        long mid = begin + (end - begin) / 2;
        CountTask task1 = new CountTask(begin, mid);
        CountTask task2 = new CountTask(mid + 1, end);
        task1.fork(); 
        task2.fork();
        Long v1 = task1.join(); 
        Long v2 = task2.join();
        return v1 + v2;
    }
}
```
上述代码，用于计算`begin + ... + end`的计算结果。当begin与end相邻时，任务已经足够小，可以直接计算(模拟耗时2s)。
否则，将任务切分为两个小任务，`fork`切分小任务, `join`获取执行结果。

貌似没有问题，可在8核机器上执行以下测试用例
```java
    @Test
    public void testForkJoin() throws ExecutionException, InterruptedException {
        ForkJoinPool pool = new ForkJoinPool();
        long begin = 1;
        long end = 16;
        CountTask task = new CountTask(begin, end);
        long start  = System.currentTimeMillis();
        ForkJoinTask<Long> longForkJoinTask = pool.submit(task);
        Long res = longForkJoinTask.get();
        System.out.println("begin " + begin + " end " + end + " result " + res + " use time " + (System.currentTimeMillis() - start) / 1000 + "s");
    }
```
最终却耗时4s，如下
> begin 1 end 16 result 136 use time 4s

我们期望耗时2s才对，8个线程在`同一时刻`开始分别执行`1+2`,`3+4`, ..., `13+14`, `15+16`，2s内执行完毕，在这之后的汇总结果，并不怎么耗时，
所以期望返回2s。

## 错误使用分析
上述错误示范中在`compute`方法中将大任务拆分为小任务时，使用的是如下方法
```java
    // 继续拆分任务
    long mid = begin + (end - begin) / 2;
    CountTask task1 = new CountTask(begin, mid);
    CountTask task2 = new CountTask(mid + 1, end);
    task1.fork(); 
    task2.fork();
    Long v1 = task1.join(); 
    Long v2 = task2.join();
```

`fork`方法会异步将子任务塞入队列，而不会阻塞；但是`join`方法会阻塞，直到任务完成返回结果。所以上述的使用方式下，`当前线程会阻塞住，直到两个子任务完成才会继续执行`。如果两个子任务恰好被两个空闲的线程`窃取`到，则这里并不会有性能影响;但是如果被两个不空闲的线程窃取到任务，则得不偿失了，当前线程此时无事可做，
会浪费cpu。因此，这里应该强制当前线程执行任务。

有两种优化方式
方式1
```java
 task1.fork();
 task2.fork();
 task2.join(); // 强制当前线程执行子任务
 task1.join();
```
方式2
```java
 invokeAll(task1, task2);  // 当前线程会直接执行task1，而其他task入队列
 task1.join();
 task2.join()
```

## 思考
模拟测试时，如何知道其实现内部细节?


- debug(debug在多线程并发下会影响测试)。
- RecursiveTask子类中打印堆栈分析框架执行逻辑。
- 利用反射工具，开启一个旁路线程实时打印框架中内部属性信息辅助分析。

**Tips**
- 在不考虑工作线程窃取任务时，研究源码逻辑，可以设置`ForkJoinPool`并发度`parallelism`值为1, 这样只会创建一个线程


参考

1. [Java的Fork/Join任务，你写对了吗？](https://www.liaoxuefeng.com/article/1146802219354112)
2. [JUC源码分析-线程池篇（四）：ForkJoinPool - 1](https://www.jianshu.com/p/32a15ef2f1bf)
3. [JUC源码分析-线程池篇（五）：ForkJoinPool - 2](https://www.jianshu.com/p/6a14d0b54b8d)
4. [并发编程的艺术]()
5. [Fork/Join框架（1）原理](https://segmentfault.com/a/1190000016781127)
6. [ForkJoinPool大型图文现场](https://juejin.cn/post/6932632481526972430)
7. [docs ForKJoinTask](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinTask.html)
8. [docs RecursiveTask](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html)
9. [ForkJoinPool Doug Lea论文](https://gee.cs.oswego.edu/dl/papers/fj.pdf)