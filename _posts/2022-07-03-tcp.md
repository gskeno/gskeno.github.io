---
layout: post
title: tcp报文讲起
tags:
- tcp
categories: network
description: tcp报文讲起
---

本文主要介绍tcp报文结构及其作用。

# TCP报文结构
<img src="/assets/img/tcp-data.jpg" width="650"/>

- 序号
  
  本TCP报文所`发送的数据`(即TCP报文的数据段部分)的第一个字节的序号。

- 确认号

  假设A发送给B一个TCP报文，报文的***确认号*** 字段值是101，则表示A期望B下次发送的报文数据序号为101
  (言外之意，B发送的序号为100的报文数据A已经接收到了)。

- 数据偏移
  
  表示TCP报文段的首部长度，4个bit最大表示15，“数据偏移”的单位是“4字节”，所以TCP`首部最多60个字节`，而`固定首部占用20个
  字节`，所以`选项部分最多占用40个字节`。

- 窗口
  
  占2字节。假设A发送给B一个TCP报文，报文的***窗口*** 字段值是50，则表示`从报文首部中的确认号算起，
  A允许B发送50个字节数据量`。窗口值作为接收方让发送方设置其发送窗口的依据。

- 选项
  - `MSS`(Maximum Segement Size) 是一个TCP报文段中的`数据字段的最大长度`，所以MSS并不是整个TCP报文段的最大长度，
    而是“TCP报文段长度 - TCP首部长度”。
    
    值太小，网络利用率就低；
    
    值太大，在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的TCP报文段。
    当传输出错时还要进行重传。这些也都会使开销增大。

    MSS选项由四个字节构成：选项类型代码为2（1字节），选项长度（1字节），选项数据（2字节）共计4字节。其中，选项数据的2字节代表了MSS的值。如果MSS选项数据为512，则表示该报文段的发送方可以处理的最大报文段长度为512字节（不包括TCP与IP协议头长度）。

    下图表示的就是利用`nc`命令模拟服务端接口监听和客户端tcp连接服务端，所引起的tcp连接三次握手和断开四次挥手。
    <img src="/assets/img/network/tcp2.jpg" width="650"/>

    这里引出一个思考题，`IP层会进行分片(MTU机制)，为什么TCP层还需要MSS进行分片呢？`

  - `Window Scale` 窗口扩大选项占3字节。其中的`Shift count` 字段表示TCP头部定义的接收窗口大小可以再左移`Shift count`位进行扩大。
    Window Scale 只在tcp连接`三次握手`时传递, 后续的业务报文不再传递该可选字段，但真实窗口的计算逻辑维持不变。

    <img src="/assets/img/network/tcp3.png" width="650"/>

  - `TimeStamps` 时间戳。
    时间戳选项占10字节，其中最主要的字段时间戳值字段（4字节）和时间戳回送回答字段（4字节）。
    
    时间戳选项有以下两个功能：
    
    第一，`用来计算往返时间RTT`。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。
    
    第二，`用于处理TCP序号超过2^32的情况`，这又称为防止序号绕回 PAWS (Protect Against Wrapped Sequence numbers)。我们知道，序号只有32位，而每增加232个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能会被重复使用。例如，若用1Gb/s的速率发送报文段，则不到35秒钟数据字节的序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。

    <img src="/assets/img/network/tcp4.png" width="650"/>

# 拥塞控制
目标
- 区分流量控制与拥塞控制
- 拥塞控制的几种常见算法

## 慢开始和拥塞避免
 <img src="/assets/img/network/tcp5.png" width="650"/>
 
 可以直观地看出，拥塞窗口是指数级快速增大，然后线性增大，直至达到网络拥塞。在达到网络拥塞时，发送者表现就是没有按时收到确认，发送者发生了`超时重传`。

## 快重传和快恢复

**快重传**

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。

在下图所示的例子中，接收方收到了M1和M2后都分别发出了确认。现假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段（按照顺序的M3还没有收到）。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对 M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送M5和M6。接收方收到后，也还要再次发出对M2的重复确认。这样，`发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认`。

快重传算法规定，`发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待为M3设置的重传计时器到期`。由于发送方能尽早重传未被确认的报文段，因此采用快重传后可以使整个网络的吞吐量提高约20%。

 <img src="/assets/img/network/tcp6.png" width="450"/>

---

**快恢复**

当`触发快重传`时，拥塞窗口骤降，`重新进入到拥塞避免`阶段。

 <img src="/assets/img/network/tcp7.png" width="450"/>


# 延迟确认与Nagle算法
延迟确认

该策略的原理是这样的：如果`收到一个包之后暂时没什么数据要发给对方，那就延迟一段时间`（在Windows上默认为200毫秒）再确认。

假如`在这段时间里恰好有数据要发送`，那确认信息和数据就可以在一个包里发出去了。

延迟确认并没有直接提高性能，它只是减少了部分确认包，减轻了网络负担。

---

Negle算法(延迟发送)

算法的原理是：在`发出去的数据还没有被确认之前`，假如又有小数据生成，那就把小数据收集起来，`凑满一个MSS或者等收到确认后`再发送。

# 参考
1. [计算机网络 谢希仁]()
2. [MSS百度百科](https://baike.baidu.com/item/MSS/3567802?fr=ge_ala)
3. [小林coding tcp](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html)
4. [Wireshark网络分析就是这么简单]()